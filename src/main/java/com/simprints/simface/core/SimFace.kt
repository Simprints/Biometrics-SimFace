package com.simprints.simface.core

import android.graphics.Bitmap
import com.simprints.simface.data.FaceDetection
import com.simprints.simface.embedding.EmbeddingProcessor
import com.simprints.simface.embedding.TensorFlowEmbeddingProcessor
import com.simprints.simface.matcher.CosineDistanceMatchProcessor
import com.simprints.simface.matcher.MatchProcessor
import com.simprints.simface.quality.FaceDetectionProcessor
import com.simprints.simface.quality.MlKitFaceDetectionProcessor

class SimFace {
    private val initLock = Any()

    // Internal processors
    private lateinit var modelManager: MLModelManager
    private lateinit var embeddingProcessor: EmbeddingProcessor
    private lateinit var matchProcessor: MatchProcessor
    private lateinit var faceDetectionProcessor: FaceDetectionProcessor

    /**
     * Load the ML model into memory and prepare other resources for work.
     */
    fun initialize(config: SimFaceConfig): Unit = synchronized(initLock) {
        try {
            // Initialize the model manager with the given config
            modelManager = MLModelManager()
            modelManager.loadModels(config.context)

            // Initialize processors
            embeddingProcessor = TensorFlowEmbeddingProcessor(modelManager)
            matchProcessor = CosineDistanceMatchProcessor()
            faceDetectionProcessor = MlKitFaceDetectionProcessor(modelManager)
        } catch (e: Exception) {
            throw RuntimeException("Failed to initialize SimFaceFacade: ${e.message}", e)
        }
    }

    /**
     * Releases used resources and ML model.
     */
    fun release() = synchronized(initLock) {
        try {
            if (this::modelManager.isInitialized) {
                modelManager.close()
            }
        } catch (e: Exception) {
            println("Error releasing MLModelManager: ${e.message}")
        }
    }

    /**
     * Returns the version of the templates generated by the underlying ML model.
     */
    fun getTemplateVersion(): String = TEMPLATE_VERSION

    /**
     * Asynchronously processes the image and finds a face on the provided image and returns
     * its metadata (quality, bounding box, landmarks, etc.) or error in a set of callbacks.
     */
    fun detectFace(
        image: Bitmap,
        onSuccess: (List<FaceDetection>) -> Unit,
        onFailure: (Exception) -> Unit = {},
        onCompleted: () -> Unit = {},
    ) {
        if (!this::faceDetectionProcessor.isInitialized) {
            throw IllegalStateException("SimFace.initialize() should be called first")
        }
        faceDetectionProcessor.detectFace(image, onSuccess, onFailure, onCompleted)
    }

    /**
     * Synchronously processes the image and finds all faces on the provided image and returns
     * their metadata (quality, bounding box, landmarks, etc.) or error in a set of callbacks.
     */
    suspend fun detectFaceBlocking(image: Bitmap): List<FaceDetection> {
        if (!this::faceDetectionProcessor.isInitialized) {
            throw IllegalStateException("SimFace.initialize() should be called first")
        }
        return faceDetectionProcessor.detectFaceBlocking(image)
    }

    /**
     * Extracts the biometric template from the provided face image.
     */
    fun getEmbedding(faceImage: Bitmap): ByteArray {
        if (!this::embeddingProcessor.isInitialized) {
            throw IllegalStateException("SimFace.initialize() should be called first")
        }
        return embeddingProcessor.getEmbedding(faceImage)
    }

    /**
     * Compares the probe against the provided reference.
     */
    fun verificationScore(
        probe: ByteArray,
        matchReference: ByteArray,
    ): Double {
        if (!this::matchProcessor.isInitialized) {
            throw IllegalStateException("SimFace.initialize() should be called first")
        }
        return matchProcessor.verificationScore(probe, matchReference)
    }

    /**
     * Compares the probe against the provided list of references and returns the scores
     * for each reference in a descending order.
     */
    fun identificationScore(
        probe: ByteArray,
        matchReferences: List<ByteArray>,
    ): List<Pair<ByteArray, Double>> {
        if (!this::matchProcessor.isInitialized) {
            throw IllegalStateException("SimFace.initialize() should be called first")
        }
        return matchProcessor.identificationScore(probe, matchReferences)
    }

    companion object {
        private const val TEMPLATE_VERSION = "SIM_FACE_BASE_1"
    }
}
