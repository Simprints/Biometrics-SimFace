package com.simprints.biometrics.simface

import android.graphics.Bitmap
import com.google.mlkit.vision.face.FaceDetection as MlKitFaceDetection
import com.google.mlkit.vision.face.FaceDetector
import com.google.mlkit.vision.face.FaceDetectorOptions
import com.simprints.biometrics.simface.data.FaceDetection
import com.simprints.biometrics.simface.detection.FaceDetectionProcessor
import com.simprints.biometrics.simface.detection.MlKitFaceDetectionProcessor
import com.simprints.biometrics.simface.embedding.EmbeddingProcessor
import com.simprints.biometrics.simface.embedding.MLModelManager
import com.simprints.biometrics.simface.embedding.TensorFlowEmbeddingProcessor
import com.simprints.biometrics.simface.matcher.CosineDistanceMatchProcessor
import com.simprints.biometrics.simface.matcher.MatchProcessor
import com.simprints.simq.SimQ
import java.util.concurrent.locks.ReentrantLock
import kotlin.concurrent.withLock

class SimFace {
    private val initLock = ReentrantLock()

    // Internal processors
    private lateinit var modelManager: MLModelManager
    private lateinit var embeddingProcessor: EmbeddingProcessor
    private lateinit var matchProcessor: MatchProcessor
    private lateinit var qualityProcessor: SimQ
    private lateinit var faceDetector: FaceDetector
    private lateinit var faceDetectionProcessor: FaceDetectionProcessor

    /** Load the ML model into memory and prepare other resources for work. */
    fun initialize(config: SimFaceConfig): Unit =
            initLock.withLock {
                try {
                    // Initialize the model manager with the given config
                    modelManager = MLModelManager(config)

                    // Initialize SimQ quality processor with optional custom weights and parameters
                    qualityProcessor =
                            when {
                                config.qualityWeights != null && config.qualityParameters != null ->
                                        SimQ(config.qualityWeights, config.qualityParameters)
                                config.qualityWeights != null ->
                                        SimQ(faceWeights = config.qualityWeights)
                                config.qualityParameters != null ->
                                        SimQ(faceParameters = config.qualityParameters)
                                else -> SimQ()
                            }

                    // Initialize processors
                    embeddingProcessor = TensorFlowEmbeddingProcessor(modelManager)
                    matchProcessor = CosineDistanceMatchProcessor()

                    // Configure and load MLKit face detection model
                    val realTimeOpts =
                            FaceDetectorOptions.Builder()
                                    .setContourMode(FaceDetectorOptions.CONTOUR_MODE_ALL)
                                    .setPerformanceMode(
                                            FaceDetectorOptions.PERFORMANCE_MODE_ACCURATE,
                                    )
                                    .setLandmarkMode(FaceDetectorOptions.LANDMARK_MODE_ALL)
                                    .setClassificationMode(
                                            FaceDetectorOptions.CLASSIFICATION_MODE_ALL,
                                    )
                                    .setMinFaceSize(0.20f)
                                    .build()
                    faceDetector = MlKitFaceDetection.getClient(realTimeOpts)
                    faceDetectionProcessor =
                            MlKitFaceDetectionProcessor(faceDetector, qualityProcessor)
                } catch (e: Exception) {
                    throw RuntimeException("Failed to initialize SimFaceFacade: ${e.message}", e)
                }
            }

    /** Releases used resources and ML model. */
    fun release() =
            initLock.withLock {
                try {
                    if (this::modelManager.isInitialized) {
                        modelManager.close()
                    }
                    if (this::faceDetector.isInitialized) {
                        faceDetector.close()
                    }
                } catch (e: Exception) {
                    println("Error releasing MLModelManager: ${e.message}")
                }
            }

    /** Returns the version of the templates generated by the underlying ML model. */
    fun getTemplateVersion(): String = modelManager.templateVersion

    /**
     * Asynchronously processes the image and finds a face on the provided image and returns its
     * metadata (quality, bounding box, landmarks, etc.) or error in a set of callbacks.
     */
    fun detectFace(
            image: Bitmap,
            onSuccess: (List<FaceDetection>) -> Unit,
            onFailure: (Exception) -> Unit = {},
            onCompleted: () -> Unit = {},
    ) {
        if (!this::faceDetectionProcessor.isInitialized) {
            throw IllegalStateException("SimFace.initialize() should be called first")
        }
        faceDetectionProcessor.detectFace(image, onSuccess, onFailure, onCompleted)
    }

    /**
     * Synchronously processes the image and finds all faces on the provided image and returns their
     * metadata (quality, bounding box, landmarks, etc.) or error in a set of callbacks.
     */
    suspend fun detectFaceBlocking(image: Bitmap): List<FaceDetection> {
        if (!this::faceDetectionProcessor.isInitialized) {
            throw IllegalStateException("SimFace.initialize() should be called first")
        }
        return faceDetectionProcessor.detectFaceBlocking(image)
    }

    /** Extracts the biometric template from the provided face image. */
    fun getEmbedding(faceImage: Bitmap): ByteArray {
        if (!this::embeddingProcessor.isInitialized) {
            throw IllegalStateException("SimFace.initialize() should be called first")
        }
        return embeddingProcessor.getEmbedding(faceImage)
    }

    /** Compares the probe against the provided reference. */
    fun verificationScore(
            probe: ByteArray,
            matchReference: ByteArray,
    ): Double {
        if (!this::matchProcessor.isInitialized) {
            throw IllegalStateException("SimFace.initialize() should be called first")
        }
        return matchProcessor.verificationScore(probe, matchReference)
    }

    /**
     * Compares the probe against the provided list of references and returns the scores for each
     * reference in a descending order.
     */
    fun identificationScore(
            probe: ByteArray,
            matchReferences: List<ByteArray>,
    ): List<Pair<ByteArray, Double>> {
        if (!this::matchProcessor.isInitialized) {
            throw IllegalStateException("SimFace.initialize() should be called first")
        }
        return matchProcessor.identificationScore(probe, matchReferences)
    }
}
